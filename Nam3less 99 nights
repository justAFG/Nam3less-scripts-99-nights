-- Rayfield UI Script - 99 Nights in the Forest
-- Nur spezifische Items werden gesammelt

local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

-- Variables
local flyEnabled = false
local playerSpeed = 16
local flySpeed = 100
local isMobile = game:GetService("UserInputService").TouchEnabled
local searchRadius = math.huge  -- Ganze Map

-- Fly System Variables
local flyConnection
local bodyVelocity
local bodyGyro
local mobileControls
local mobileFlyConnection

-- Mobile control variables
local upPressed = false
local downPressed = false
local forwardPressed = false
local backwardPressed = false
local leftPressed = false
local rightPressed = false

-- Create Interface
local Window = Rayfield:CreateWindow({
   Name = "99 Nights Tools",
   LoadingTitle = "Loading Interface...",
   LoadingSubtitle = "By ScriptHub",
   ConfigurationSaving = {
      Enabled = false
   }
})

-- Main Tab
local MainTab = Window:CreateTab("Main Features", nil)

-- Fly Toggle
local FlyToggle = MainTab:CreateToggle({
   Name = "ðŸš€ Flight Mode",
   CurrentValue = false,
   Callback = function(Value)
       flyEnabled = Value
       if flyEnabled then
           activateFly()
           if isMobile then
               createMobileControls()
           end
           Rayfield:Notify({
               Title = "Flight Enabled",
               Content = isMobile and "Use mobile controls to fly" or "Use WASD + Space/Shift to fly",
               Duration = 4,
           })
       else
           deactivateFly()
           if isMobile then
               removeMobileControls()
           end
           Rayfield:Notify({
               Title = "Flight Disabled",
               Content = "Flight mode deactivated",
               Duration = 2,
           })
       end
   end,
})

-- Player Speed Slider
local SpeedSlider = MainTab:CreateSlider({
   Name = "ðŸ‘Ÿ Player Speed",
   Range = {16, 200},
   Increment = 1,
   Suffix = "studs/s",
   CurrentValue = 16,
   Callback = function(Value)
       playerSpeed = Value
       updatePlayerSpeed()
   end,
})

-- Fly Speed Slider
local FlySpeedSlider = MainTab:CreateSlider({
   Name = "âš¡ Flight Speed",
   Range = {50, 300},
   Increment = 10,
   Suffix = "studs/s",
   CurrentValue = 100,
   Callback = function(Value)
       flySpeed = Value
   end,
})

-- Teleport Tab
local TeleportTab = Window:CreateTab("Teleport", nil)

-- Base Teleport Section
TeleportTab:CreateSection("ðŸ  Teleport to Base")

local TeleportBaseButton = TeleportTab:CreateButton({
   Name = "ðŸ  Teleport to Base",
   Callback = function()
       teleportToBase()
   end,
})

-- Cultist Generator Teleport Section
TeleportTab:CreateSection("ðŸ”® Cultist Generator")

local TeleportCultistButton = TeleportTab:CreateButton({
   Name = "ðŸ”® Teleport to Cultist Generator",
   Callback = function()
       teleportToCultistGenerator()
   end,
})

-- Volcano Teleport Section
TeleportTab:CreateSection("ðŸŒ‹ Volcano")

local TeleportVolcanoButton = TeleportTab:CreateButton({
   Name = "ðŸŒ‹ Teleport to Volcano",
   Callback = function()
       teleportToVolcano()
   end,
})

-- Teleport Status
TeleportTab:CreateSection("ðŸ“Š Teleport Status")

local TeleportStatusLabel = TeleportTab:CreateLabel("Ready for teleport")

-- Items Tab
local ItemsTab = Window:CreateTab("Items", nil)

-- Log Section
ItemsTab:CreateSection("ðŸªµ Log")

local BringLogButton = ItemsTab:CreateButton({
   Name = "ðŸªµ Bring Logs",
   Callback = function()
       bringLogsOnly()
   end,
})

-- Fuel Section
ItemsTab:CreateSection("â›½ Fuel")

local BringFuelButton = ItemsTab:CreateButton({
   Name = "â›½ Bring Fuel",
   Callback = function()
       bringFuel()
   end,
})

-- Food Section
ItemsTab:CreateSection("ðŸŽ Food")

local BringFoodButton = ItemsTab:CreateButton({
   Name = "ðŸŽ Bring Food",
   Callback = function()
       bringFood()
   end,
})

-- Heal Section
ItemsTab:CreateSection("â¤ï¸ Heal")

local BringHealButton = ItemsTab:CreateButton({
   Name = "ðŸ©¹ Bring Heal Items",
   Callback = function()
       bringHealItems()
   end,
})

-- Scrap Section
ItemsTab:CreateSection("ðŸ”§ Scrap")

local BringScrapButton = ItemsTab:CreateButton({
   Name = "ðŸ”§ Bring All Scrap",
   Callback = function()
       bringAllScrap()
   end,
})

-- Volcano Items Section
ItemsTab:CreateSection("ðŸŒ‹ Volcano Items")

local BringVolcanoItemsButton = ItemsTab:CreateButton({
   Name = "ðŸŒ‹ Bring Volcano Items",
   Callback = function()
       bringVolcanoItems()
   end,
})

-- Status Display
ItemsTab:CreateSection("ðŸ“Š Status")

local ItemsStatusLabel = ItemsTab:CreateLabel("Ready for item collection")

-- TELEPORT FUNCTIONS --
function teleportToCultistGenerator()
    Rayfield:Notify({
        Title = "Searching for Cultist Generator",
        Content = "Looking for Cultist Generator Base...",
        Duration = 3,
    })
    
    TeleportStatusLabel:Set("Searching for Cultist Generator Base...")
    
    local targetPosition = nil
    local foundObject = nil
    local foundType = ""
    
    -- Search for Cultist Generator objects
    for _, obj in pairs(game:GetService("Workspace"):GetDescendants()) do
        if obj:IsA("Part") or obj:IsA("Model") then
            local objName = string.lower(obj.Name)
            
            -- Check for Cultist Generator related names
            if string.find(objName, "cultist") and string.find(objName, "generator") then
                targetPosition = getObjectPosition(obj)
                foundObject = obj
                foundType = obj.Name
                break
            end
        end
    end
    
    -- If not found, search for specific Cultist Generator parts
    if not targetPosition then
        TeleportStatusLabel:Set("Searching for Cultist Generator parts...")
        
        local cultistNames = {
            "CultistGenerator", "Cultist Generator", "CultistGeneratorBase",
            "Cultist Base", "CultistAltar", "CultistRitual"
        }
        
        for _, partName in pairs(cultistNames) do
            local obj = findObjectInWorkspace(partName)
            if obj then
                targetPosition = getObjectPosition(obj)
                foundObject = obj
                foundType = obj.Name
                break
            end
        end
    end
    
    -- If still not found, search for any ritual or cultist related objects
    if not targetPosition then
        TeleportStatusLabel:Set("Searching for ritual objects...")
        
        local ritualKeywords = {"cultist", "ritual", "altar", "sacrifice", "summon", "dark", "evil"}
        for _, obj in pairs(game:GetService("Workspace"):GetDescendants()) do
            if obj:IsA("Part") or obj:IsA("Model") then
                local objName = string.lower(obj.Name)
                for _, keyword in pairs(ritualKeywords) do
                    if string.find(objName, keyword) then
                        targetPosition = getObjectPosition(obj)
                        foundObject = obj
                        foundType = obj.Name
                        break
                    end
                end
                if targetPosition then break end
            end
        end
    end
    
    if targetPosition then
        safeTeleport(targetPosition)
        TeleportStatusLabel:Set("âœ… Teleported to " .. foundType)
        Rayfield:Notify({
            Title = "Cultist Generator Teleport Successful",
            Content = "Teleported to " .. foundType,
            Duration = 4,
        })
        
        -- Debug info
        print("ðŸ”® Teleported to: " .. foundType)
        print("ðŸ“ Position: " .. tostring(targetPosition))
        if foundObject then
            print("ðŸ“ Object Path: " .. foundObject:GetFullName())
        end
    else
        TeleportStatusLabel:Set("âŒ No Cultist Generator found")
        Rayfield:Notify({
            Title = "Cultist Generator Not Found",
            Content = "Could not find Cultist Generator Base",
            Duration = 4,
        })
    end
end

function teleportToVolcano()
    Rayfield:Notify({
        Title = "Searching for Volcano",
        Content = "Looking for Volcano...",
        Duration = 3,
    })
    
    TeleportStatusLabel:Set("Searching for Volcano...")
    
    local targetPosition = nil
    local foundObject = nil
    local foundType = ""
    
    -- Search for Volcano objects
    for _, obj in pairs(game:GetService("Workspace"):GetDescendants()) do
        if obj:IsA("Part") or obj:IsA("Model") then
            local objName = string.lower(obj.Name)
            
            -- Check for Volcano related names
            if string.find(objName, "volcano") or string.find(objName, "lava") or string.find(objName, "magma") then
                targetPosition = getObjectPosition(obj)
                foundObject = obj
                foundType = obj.Name
                break
            end
        end
    end
    
    -- If not found, search for specific Volcano parts
    if not targetPosition then
        TeleportStatusLabel:Set("Searching for Volcano parts...")
        
        local volcanoNames = {
            "Volcano", "Lava", "Magma", "Mountain", "Crater",
            "VolcanoBase", "VolcanoTop", "VolcanoCrater"
        }
        
        for _, partName in pairs(volcanoNames) do
            local obj = findObjectInWorkspace(partName)
            if obj then
                targetPosition = getObjectPosition(obj)
                foundObject = obj
                foundType = obj.Name
                break
            end
        end
    end
    
    -- If still not found, search for any large mountain-like structures
    if not targetPosition then
        TeleportStatusLabel:Set("Searching for large mountain structures...")
        
        for _, obj in pairs(game:GetService("Workspace"):GetDescendants()) do
            if obj:IsA("Part") and obj.Size.Magnitude > 100 then
                -- Check if it looks like a mountain/volcano (large and tall)
                if obj.Position.Y > 50 and obj.Size.Y > 50 then
                    targetPosition = obj.Position + Vector3.new(0, 20, 0)
                    foundObject = obj
                    foundType = "Large Mountain Structure"
                    break
                end
            end
        end
    end
    
    if targetPosition then
        safeTeleport(targetPosition)
        TeleportStatusLabel:Set("âœ… Teleported to " .. foundType)
        Rayfield:Notify({
            Title = "Volcano Teleport Successful",
            Content = "Teleported to " .. foundType,
            Duration = 4,
        })
        
        -- Debug info
        print("ðŸŒ‹ Teleported to: " .. foundType)
        print("ðŸ“ Position: " .. tostring(targetPosition))
        if foundObject then
            print("ðŸ“ Object Path: " .. foundObject:GetFullName())
        end
    else
        TeleportStatusLabel:Set("âŒ No Volcano found")
        Rayfield:Notify({
            Title = "Volcano Not Found",
            Content = "Could not find Volcano",
            Duration = 4,
        })
    end
end

function teleportToBase()
    Rayfield:Notify({
        Title = "Searching for Base",
        Content = "Looking for SpawnLocation...",
        Duration = 3,
    })
    
    TeleportStatusLabel:Set("Searching for SpawnLocation...")
    
    local targetPosition = nil
    local foundObject = nil
    local foundType = ""
    
    -- First search for SpawnLocation
    for _, obj in pairs(game:GetService("Workspace"):GetDescendants()) do
        if obj:IsA("Part") and obj.Name == "SpawnLocation" then
            targetPosition = obj.Position
            foundObject = obj
            foundType = "SpawnLocation"
            break
        end
    end
    
    -- If SpawnLocation not found, search for MainFire
    if not targetPosition then
        TeleportStatusLabel:Set("SpawnLocation not found, searching for MainFire...")
        
        for _, obj in pairs(game:GetService("Workspace"):GetDescendants()) do
            if (obj:IsA("Part") or obj:IsA("Model")) and string.lower(obj.Name) == "mainfire" then
                targetPosition = getObjectPosition(obj)
                foundObject = obj
                foundType = "MainFire"
                break
            end
        end
    end
    
    -- If still not found, search for any fire or spawn related objects
    if not targetPosition then
        TeleportStatusLabel:Set("Searching for any base objects...")
        
        local baseKeywords = {"fire", "spawn", "base", "camp", "home"}
        for _, obj in pairs(game:GetService("Workspace"):GetDescendants()) do
            if obj:IsA("Part") or obj:IsA("Model") then
                local objName = string.lower(obj.Name)
                for _, keyword in pairs(baseKeywords) do
                    if string.find(objName, keyword) then
                        targetPosition = getObjectPosition(obj)
                        foundObject = obj
                        foundType = obj.Name
                        break
                    end
                end
                if targetPosition then break end
            end
        end
    end
    
    if targetPosition then
        safeTeleport(targetPosition)
        TeleportStatusLabel:Set("âœ… Teleported to " .. foundType)
        Rayfield:Notify({
            Title = "Teleport Successful",
            Content = "Teleported to " .. foundType .. " at base",
            Duration = 4,
        })
        
        -- Debug info
        print("ðŸŽ¯ Teleported to: " .. foundType)
        print("ðŸ“ Position: " .. tostring(targetPosition))
        if foundObject then
            print("ðŸ“ Object Path: " .. foundObject:GetFullName())
        end
    else
        TeleportStatusLabel:Set("âŒ No base location found")
        Rayfield:Notify({
            Title = "Base Not Found",
            Content = "Could not find SpawnLocation or MainFire",
            Duration = 4,
        })
    end
end

function findObjectInWorkspace(objectName)
    -- Search in Workspace first
    local obj = game:GetService("Workspace"):FindFirstChild(objectName)
    if obj then return obj end
    
    -- Search in all descendants
    for _, child in pairs(game:GetService("Workspace"):GetDescendants()) do
        if child.Name == objectName then
            return child
        end
    end
    
    return nil
end

function getObjectPosition(obj)
    if obj:IsA("Model") then
        local primaryPart = obj.PrimaryPart or obj:FindFirstChildWhichIsA("BasePart")
        if primaryPart then
            return primaryPart.Position
        else
            -- Get average position of all parts
            local totalPosition = Vector3.new(0, 0, 0)
            local partCount = 0
            
            for _, part in pairs(obj:GetDescendants()) do
                if part:IsA("BasePart") then
                    totalPosition = totalPosition + part.Position
                    partCount = partCount + 1
                end
            end
            
            if partCount > 0 then
                return totalPosition / partCount
            end
        end
    elseif obj:IsA("Part") or obj:IsA("MeshPart") then
        return obj.Position
    end
    return Vector3.new(0, 0, 0)
end

function safeTeleport(position)
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then 
        Rayfield:Notify({
            Title = "Error",
            Content = "No character found",
            Duration = 3,
        })
        return 
    end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then
        Rayfield:Notify({
            Title = "Error", 
            Content = "No HumanoidRootPart found",
            Duration = 3,
        })
        return
    end
    
    -- Find safe position (not inside objects)
    local safePosition = getSafePosition(position)
    
    -- Teleport player
    humanoidRootPart.CFrame = CFrame.new(safePosition)
    
    -- Small delay and re-check
    wait(0.1)
    humanoidRootPart.CFrame = CFrame.new(safePosition)
    
    print("ðŸŽ¯ Teleported to safe position: " .. tostring(safePosition))
end

function getSafePosition(targetPosition)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    if game.Players.LocalPlayer.Character then
        raycastParams.FilterDescendantsInstances = {game.Players.LocalPlayer.Character}
    end
    
    -- Raycast to find safe position
    local raycastResult = workspace:Raycast(
        targetPosition + Vector3.new(0, 50, 0),  -- Start from above
        Vector3.new(0, -100, 0),                 -- Raycast down
        raycastParams
    )
    
    if raycastResult then
        return raycastResult.Position + Vector3.new(0, 3, 0)  -- Slightly above ground
    else
        return targetPosition + Vector3.new(0, 5, 0)  -- Default safe height
    end
end

-- BRING ITEMS FUNCTIONS --
function bringVolcanoItems()
    Rayfield:Notify({
        Title = "Collecting Volcano Items",
        Content = "Searching for specific volcano items...",
        Duration = 3,
    })
    
    local obsidianCollected = 0
    local lavaRockCollected = 0
    local volcanicCrystalCollected = 0
    local magmaStoneCollected = 0
    local workspace = game:GetService("Workspace")
    
    -- NUR spezifische Volcano Items
    local volcanoItems = {
        "Obsidian",
        "Lava Rock", 
        "Volcanic Crystal",
        "Magma Stone"
    }
    
    for _, item in pairs(workspace:GetDescendants()) do
        if item:IsA("Part") or item:IsA("MeshPart") or item:IsA("Model") then
            local itemName = item.Name -- EXAKTER Name
            
            -- NUR die spezifischen Items
            if itemName == "Obsidian" then
                moveItemToPlayer(item)
                obsidianCollected = obsidianCollected + 1
                wait(0.05)
            elseif itemName == "Lava Rock" then
                moveItemToPlayer(item)
                lavaRockCollected = lavaRockCollected + 1
                wait(0.05)
            elseif itemName == "Volcanic Crystal" then
                moveItemToPlayer(item)
                volcanicCrystalCollected = volcanicCrystalCollected + 1
                wait(0.05)
            elseif itemName == "Magma Stone" then
                moveItemToPlayer(item)
                magmaStoneCollected = magmaStoneCollected + 1
                wait(0.05)
            end
        end
    end
    
    ItemsStatusLabel:Set("Collected: " .. obsidianCollected .. " Obsidian, " .. lavaRockCollected .. " Lava Rocks, " .. volcanicCrystalCollected .. " Crystals, " .. magmaStoneCollected .. " Magma Stones")
    Rayfield:Notify({
        Title = "Volcano Items Collection Complete",
        Content = "Collected: " .. obsidianCollected .. " Obsidian, " .. lavaRockCollected .. " Lava Rocks, " .. volcanicCrystalCollected .. " Volcanic Crystals, " .. magmaStoneCollected .. " Magma Stones",
        Duration = 6,
    })
end

function bringLogsOnly()
    Rayfield:Notify({
        Title = "Collecting Logs",
        Content = "Searching for 'Log' items...",
        Duration = 3,
    })
    
    local itemsCollected = 0
    local workspace = game:GetService("Workspace")
    
    for _, item in pairs(workspace:GetDescendants()) do
        if item:IsA("Part") or item:IsA("MeshPart") or item:IsA("Model") then
            local itemName = item.Name -- EXAKTER Name
            
            -- NUR "Log" (nicht "Logs", "LogPile", etc.)
            if itemName == "Log" then
                moveItemToPlayer(item)
                itemsCollected = itemsCollected + 1
                wait(0.05)
            end
        end
    end
    
    ItemsStatusLabel:Set("Collected " .. itemsCollected .. " Logs")
    Rayfield:Notify({
        Title = "Log Collection Complete",
        Content = "Collected " .. itemsCollected .. " Log items",
        Duration = 4,
    })
end

function bringFuel()
    Rayfield:Notify({
        Title = "Collecting Fuel",
        Content = "Searching for specific fuel items...",
        Duration = 3,
    })
    
    local coalCollected = 0
    local oilCanisterCollected = 0
    local chairCollected = 0
    local fuelCanisterCollected = 0
    local workspace = game:GetService("Workspace")
    
    for _, item in pairs(workspace:GetDescendants()) do
        if item:IsA("Part") or item:IsA("MeshPart") or item:IsA("Model") then
            local itemName = item.Name -- EXAKTER Name
            
            -- NUR die spezifischen Items
            if itemName == "Coal" then
                moveItemToPlayer(item)
                coalCollected = coalCollected + 1
                wait(0.05)
            elseif itemName == "Oil Canister" then
                moveItemToPlayer(item)
                oilCanisterCollected = oilCanisterCollected + 1
                wait(0.05)
            elseif itemName == "Chair" then
                moveItemToPlayer(item)
                chairCollected = chairCollected + 1
                wait(0.05)
            elseif itemName == "Fuel Canister" then
                moveItemToPlayer(item)
                fuelCanisterCollected = fuelCanisterCollected + 1
                wait(0.05)
            end
        end
    end
    
    ItemsStatusLabel:Set("Collected: " .. coalCollected .. " Coal, " .. oilCanisterCollected .. " Oil, " .. chairCollected .. " Chairs, " .. fuelCanisterCollected .. " Fuel Canisters")
    Rayfield:Notify({
        Title = "Fuel Collection Complete",
        Content = "Collected: " .. coalCollected .. " Coal, " .. oilCanisterCollected .. " Oil Canisters, " .. chairCollected .. " Chairs, " .. fuelCanisterCollected .. " Fuel Canisters",
        Duration = 6,
    })
end

function bringFood()
    Rayfield:Notify({
        Title = "Collecting Food",
        Content = "Searching for specific food items...",
        Duration = 3,
    })
    
    local carrotCollected = 0
    local berryCollected = 0
    local morselCollected = 0
    local steakCollected = 0
    local workspace = game:GetService("Workspace")
    
    for _, item in pairs(workspace:GetDescendants()) do
        if item:IsA("Part") or item:IsA("MeshPart") or item:IsA("Model") then
            local itemName = item.Name -- EXAKTER Name
            
            -- NUR die spezifischen Items
            if itemName == "Carrot" then
                moveItemToPlayer(item)
                carrotCollected = carrotCollected + 1
                wait(0.05)
            elseif itemName == "Berry" then
                moveItemToPlayer(item)
                berryCollected = berryCollected + 1
                wait(0.05)
            elseif itemName == "Morsel" then
                moveItemToPlayer(item)
                morselCollected = morselCollected + 1
                wait(0.05)
            elseif itemName == "Steak" then
                moveItemToPlayer(item)
                steakCollected = steakCollected + 1
                wait(0.05)
            end
        end
    end
    
    ItemsStatusLabel:Set("Collected: " .. carrotCollected .. " Carrots, " .. berryCollected .. " Berries, " .. morselCollected .. " Morsels, " .. steakCollected .. " Steaks")
    Rayfield:Notify({
        Title = "Food Collection Complete",
        Content = "Collected: " .. carrotCollected .. " Carrots, " .. berryCollected .. " Berries, " .. morselCollected .. " Morsels, " .. steakCollected .. " Steaks",
        Duration = 6,
    })
end

function bringHealItems()
    Rayfield:Notify({
        Title = "Collecting Heal Items",
        Content = "Searching for specific heal items...",
        Duration = 3,
    })
    
    local bandagesCollected = 0
    local medkitsCollected = 0
    local workspace = game:GetService("Workspace")
    
    for _, item in pairs(workspace:GetDescendants()) do
        if item:IsA("Part") or item:IsA("MeshPart") or item:IsA("Model") then
            local itemName = item.Name -- EXAKTER Name
            
            -- NUR die spezifischen Items
            if itemName == "Bandage" then
                moveItemToPlayer(item)
                bandagesCollected = bandagesCollected + 1
                wait(0.05)
            elseif itemName == "Medkit" then
                moveItemToPlayer(item)
                medkitsCollected = medkitsCollected + 1
                wait(0.05)
            end
        end
    end
    
    ItemsStatusLabel:Set("Collected: " .. bandagesCollected .. " Bandages, " .. medkitsCollected .. " Medkits")
    Rayfield:Notify({
        Title = "Heal Items Collection Complete",
        Content = "Collected: " .. bandagesCollected .. " Bandages, " .. medkitsCollected .. " Medkits",
        Duration = 5,
    })
end

function bringAllScrap()
    Rayfield:Notify({
        Title = "Collecting Scrap Items",
        Content = "Searching for specific scrap items...",
        Duration = 3,
    })
    
    local tyreCollected = 0
    local washingMachineCollected = 0
    local microwaveCollected = 0
    local carEngineCollected = 0
    local oldRadioCollected = 0
    local sheetMetalCollected = 0
    local boltCollected = 0
    local brokenFanCollected = 0
    local workspace = game:GetService("Workspace")
    
    for _, item in pairs(workspace:GetDescendants()) do
        if item:IsA("Part") or item:IsA("MeshPart") or item:IsA("Model") then
            local itemName = item.Name -- EXAKTER Name
            
            -- NUR die spezifischen Items
            if itemName == "Tyre" or itemName == "Tire" then
                moveItemToPlayer(item)
                tyreCollected = tyreCollected + 1
                wait(0.05)
            elseif itemName == "Washing Machine" then
                moveItemToPlayer(item)
                washingMachineCollected = washingMachineCollected + 1
                wait(0.05)
            elseif itemName == "Broken Microwave" then
                moveItemToPlayer(item)
                microwaveCollected = microwaveCollected + 1
                wait(0.05)
            elseif itemName == "Old Car Engine" then
                moveItemToPlayer(item)
                carEngineCollected = carEngineCollected + 1
                wait(0.05)
            elseif itemName == "Old Radio" then
                moveItemToPlayer(item)
                oldRadioCollected = oldRadioCollected + 1
                wait(0.05)
            elseif itemName == "Sheet Metal" then
                moveItemToPlayer(item)
                sheetMetalCollected = sheetMetalCollected + 1
                wait(0.05)
            elseif itemName == "Bolt" then
                moveItemToPlayer(item)
                boltCollected = boltCollected + 1
                wait(0.05)
            elseif itemName == "Broken Fan" then
                moveItemToPlayer(item)
                brokenFanCollected = brokenFanCollected + 1
                wait(0.05)
            end
        end
    end
    
    ItemsStatusLabel:Set("Collected: " .. tyreCollected .. " Tyres, " .. washingMachineCollected .. " Washing Machines, " .. microwaveCollected .. " Microwaves, " .. carEngineCollected .. " Car Engines, " .. oldRadioCollected .. " Radios, " .. sheetMetalCollected .. " Sheet Metal, " .. boltCollected .. " Bolts, " .. brokenFanCollected .. " Fans")
    Rayfield:Notify({
        Title = "Scrap Collection Complete",
        Content = "Collected: " .. tyreCollected .. " Tyres, " .. washingMachineCollected .. " Washing Machines, " .. microwaveCollected .. " Microwaves, " .. carEngineCollected .. " Car Engines, " .. oldRadioCollected .. " Radios, " .. sheetMetalCollected .. " Sheet Metal, " .. boltCollected .. " Bolts, " .. brokenFanCollected .. " Fans",
        Duration = 8,
    })
end

function moveItemToPlayer(item)
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return end
    
    pcall(function()
        if item:IsA("Model") then
            local primaryPart = item.PrimaryPart or item:FindFirstChildWhichIsA("BasePart")
            if primaryPart then
                item:SetPrimaryPartCFrame(CFrame.new(humanoidRootPart.Position + Vector3.new(0, 3, 0)))
            end
        else
            item.CFrame = CFrame.new(humanoidRootPart.Position + Vector3.new(0, 3, 0))
        end
    end)
end

-- FLY SYSTEM --
function activateFly()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then
        character = player.CharacterAdded:Wait()
        wait(1)
    end
    
    deactivateFly()
    
    if not character:FindFirstChild("HumanoidRootPart") then
        Rayfield:Notify({
            Title = "Error",
            Content = "No HumanoidRootPart found",
            Duration = 3,
        })
        return
    end
    
    local rootPart = character.HumanoidRootPart
    
    -- Create BodyVelocity for movement
    bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.Velocity = Vector3.new(0, 0, 0)
    bodyVelocity.MaxForce = Vector3.new(40000, 40000, 40000)
    bodyVelocity.P = 1250
    bodyVelocity.Parent = rootPart
    
    -- Create BodyGyro for stability
    bodyGyro = Instance.new("BodyGyro")
    bodyGyro.MaxTorque = Vector3.new(40000, 40000, 40000)
    bodyGyro.P = 3000
    bodyGyro.D = 200
    bodyGyro.CFrame = rootPart.CFrame
    bodyGyro.Parent = rootPart
    
    -- Fly control loop
    if not isMobile then
        flyConnection = game:GetService("RunService").Heartbeat:Connect(function()
            if not flyEnabled or not character or not rootPart.Parent then
                deactivateFly()
                return
            end
            
            local moveDirection = Vector3.new(0, 0, 0)
            
            if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.W) then
                moveDirection = moveDirection + rootPart.CFrame.LookVector
            end
            if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.S) then
                moveDirection = moveDirection - rootPart.CFrame.LookVector
            end
            if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.A) then
                moveDirection = moveDirection - rootPart.CFrame.RightVector
            end
            if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.D) then
                moveDirection = moveDirection + rootPart.CFrame.RightVector
            end
            
            local verticalSpeed = 0
            if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.Space) then
                verticalSpeed = verticalSpeed + 1
            end
            if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.LeftShift) then
                verticalSpeed = verticalSpeed - 1
            end
            
            if moveDirection.Magnitude > 0 then
                moveDirection = moveDirection.Unit * flySpeed
            end
            
            bodyVelocity.Velocity = Vector3.new(
                moveDirection.X,
                verticalSpeed * flySpeed,
                moveDirection.Z
            )
            
            bodyGyro.CFrame = rootPart.CFrame
        end)
    else
        mobileFlyConnection = game:GetService("RunService").Heartbeat:Connect(function()
            if not flyEnabled or not character or not rootPart.Parent then
                return
            end
            
            local moveDirection = Vector3.new(0, 0, 0)
            
            if forwardPressed then moveDirection = moveDirection + rootPart.CFrame.LookVector end
            if backwardPressed then moveDirection = moveDirection - rootPart.CFrame.LookVector end
            if leftPressed then moveDirection = moveDirection - rootPart.CFrame.RightVector end
            if rightPressed then moveDirection = moveDirection + rootPart.CFrame.RightVector end
            
            local verticalSpeed = 0
            if upPressed then verticalSpeed = verticalSpeed + 1 end
            if downPressed then verticalSpeed = verticalSpeed - 1 end
            
            if moveDirection.Magnitude > 0 then
                moveDirection = moveDirection.Unit * flySpeed
            end
            
            bodyVelocity.Velocity = Vector3.new(
                moveDirection.X,
                verticalSpeed * flySpeed,
                moveDirection.Z
            )
            
            bodyGyro.CFrame = rootPart.CFrame
        end)
    end
    
    local humanoid = character:FindFirstChild("Humanoid")
    if humanoid then
        humanoid.PlatformStand = true
    end
end

function deactivateFly()
    upPressed = false
    downPressed = false
    forwardPressed = false
    backwardPressed = false
    leftPressed = false
    rightPressed = false
    
    if flyConnection then flyConnection:Disconnect(); flyConnection = nil end
    if mobileFlyConnection then mobileFlyConnection:Disconnect(); mobileFlyConnection = nil end
    
    local player = game.Players.LocalPlayer
    if player and player.Character then
        local rootPart = player.Character:FindFirstChild("HumanoidRootPart")
        if rootPart then
            if bodyVelocity then bodyVelocity:Destroy(); bodyVelocity = nil end
            if bodyGyro then bodyGyro:Destroy(); bodyGyro = nil end
        end
        
        local humanoid = player.Character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.PlatformStand = false
        end
    end
end

-- MOBILE CONTROLS --
function createMobileControls()
    removeMobileControls()
    
    local player = game.Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")
    
    mobileControls = Instance.new("ScreenGui")
    mobileControls.Name = "MobileFlyControls"
    mobileControls.ResetOnSpawn = false
    mobileControls.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    
    -- Up Button
    local upButton = createMobileButton("â†‘", UDim2.new(1, -120, 0.3, 0), Color3.fromRGB(0, 200, 0))
    upButton.MouseButton1Down:Connect(function() upPressed = true end)
    upButton.MouseButton1Up:Connect(function() upPressed = false end)
    
    -- Down Button
    local downButton = createMobileButton("â†“", UDim2.new(1, -120, 0.3, 70), Color3.fromRGB(200, 0, 0))
    downButton.MouseButton1Down:Connect(function() downPressed = true end)
    downButton.MouseButton1Up:Connect(function() downPressed = false end)
    
    -- Movement Buttons
    local forwardButton = createMobileButton("W", UDim2.new(0, 120, 0.6, -60), Color3.fromRGB(100, 100, 255))
    forwardButton.MouseButton1Down:Connect(function() forwardPressed = true end)
    forwardButton.MouseButton1Up:Connect(function() forwardPressed = false end)
    
    local backwardButton = createMobileButton("S", UDim2.new(0, 120, 0.6, 60), Color3.fromRGB(100, 100, 255))
    backwardButton.MouseButton1Down:Connect(function() backwardPressed = true end)
    backwardButton.MouseButton1Up:Connect(function() backwardPressed = false end)
    
    local leftButton = createMobileButton("A", UDim2.new(0, 60, 0.6, 0), Color3.fromRGB(100, 100, 255))
    leftButton.MouseButton1Down:Connect(function() leftPressed = true end)
    leftButton.MouseButton1Up:Connect(function() leftPressed = false end)
    
    local rightButton = createMobileButton("D", UDim2.new(0, 180, 0.6, 0), Color3.fromRGB(100, 100, 255))
    rightButton.MouseButton1Down:Connect(function() rightPressed = true end)
    rightButton.MouseButton1Up:Connect(function() rightPressed = false end)
    
    mobileControls.Parent = playerGui
end

function createMobileButton(text, position, color)
    local button = Instance.new("TextButton")
    button.Size = UDim2.new(0, 60, 0, 60)
    button.Position = position
    button.BackgroundColor3 = color
    button.Text = text
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.TextSize = 18
    button.Font = Enum.Font.SourceSansBold
    button.ZIndex = 10
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 8)
    corner.Parent = button
    
    button.Parent = mobileControls
    return button
end

function removeMobileControls()
    if mobileControls then
        mobileControls:Destroy()
        mobileControls = nil
    end
end

-- PLAYER SPEED SYSTEM --
function updatePlayerSpeed()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if character and character:FindFirstChild("Humanoid") then
        character.Humanoid.WalkSpeed = playerSpeed
    end
end

-- AUTO SETUP --
game:GetService("Players").LocalPlayer.CharacterAdded:Connect(function(character)
    wait(1)
    updatePlayerSpeed()
    if flyEnabled then
        wait(0.5)
        activateFly()
        if isMobile then
            wait(0.2)
            createMobileControls()
        end
    end
end)

-- INITIAL SETUP --
updatePlayerSpeed()

-- CLEANUP --
game:GetService("Players").LocalPlayer.CharacterRemoving:Connect(function()
    deactivateFly()
    if isMobile then
        removeMobileControls()
    end
end)

-- SUCCESS NOTIFICATION --
Rayfield:Notify({
    Title = "99 Nights Tools Loaded",
    Content = "Fly + Item Collection + Teleport System Ready! (Only Specific Items)",
    Duration = 5,
})
